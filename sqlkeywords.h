/*
    Copyright (C) 2014 Luis M. Santos
    Contact: luismigue1234@hotmail.com

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Lesser General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public License
    along with This program.  If not, see <http://www.gnu.org/licenses/>.
*/
#ifndef SQLKEYWORDS_H_INCLUDED
#define SQLKEYWORDS_H_INCLUDED

/*Because I want to give multiple ways for the user to be able to generate sql queries, the following set of enums and
structures are meant to allow the user to call a funtion with a couple of settings and obtain a full sql query out of it.
This is not a perfect system and requires hardcoding of all possible combination of switches, but it should simplify
query generation for very simple queries! :D
*/

#include <string>
#include <map>
#include <iostream>
#include "typedefs.h"

typedef unsigned short word;

/*Keywords enumerated in 16bit word format. The idea is that, if you want to build a statement, you can pass to statementType
in the generator multiple keywords in the format x|y|z. Thus, the SQL statement SELECT * FROM y can be generated by evaluating
whether statementType = SELECT | FROM. Since this is a binary OR evaluation, you obtain a value that is a merged version of
SELECT and FROM binary values! :D
*/
enum StatementTypes
{
    CREATETABLE =   0b0000000000000001,
    SELECT =        0b0000000000000010,
    INSERT =        0b0000000000000100,
    DELETE =        0b0000000000001000,
    WHERE =         0b0000000000010000,
    AS =            0b0000000000100000,
    CALL =          0b0000000001000000,
    FROM =          0b0000000010000000,
    TO =            0b0000000100000000,
    UPDATE =        0b0000001000000000,
    AND =           0b0000010000000000,
    OR =            0b0000100000000000,
    LIKE =          0b0001000000000000,
    CREATEDATABASE =0b0010000000000000,
    INTO =          0b0100000000000000,
    IN =            0b1000000000000000,
    ALL =           UPDATE | INSERT | AND | OR,
    AOR =           AND | OR, //Substitute for the AND OR keyword combination
    ORDERBY =       IN | TO | UPDATE,
    VALUES =        LIKE | AS,
    SET =           UPDATE | INTO,
    AS_TABLE =      AS | CREATETABLE,
    INNER_JOIN =    INSERT | IN,
    ON =            AS | AND,
    JOIN =          INNER_JOIN,
    LEFT_JOIN =     JOIN | OR,
    LEFT_OUTER_JOIN=LEFT_JOIN,
    BETWEEN =       IN | VALUES,
    RIGHT_JOIN =    JOIN | CALL,
    RIGHT_OUTER_JOIN=RIGHT_JOIN,
    FULL_JOIN =     JOIN | CALL | OR,
    FULL_OUTER_JOIN=FULL_JOIN,
    INTO_SELECT =   INTO | SELECT | CALL,
    UNION =         AS | LIKE | INTO,
};

/*The following map is used by the generators to quickly generate the query statement while using as little memory as
possible. In other words, the compiler doesn't have to add assembly code every time I write SELECT in the switch statement.
The program doesn't have to allocate memory for each SELECT either! The users can also use this map in their custom
generator implementations.
*/
static std::map<word, std::string> Keywords
{
    {CREATETABLE    , "CREATE TABLE \0"},
    {SELECT         , "SELECT \0"},
    {INSERT         , "INSERT \0"},
    {DELETE         , "DELETE \0"},
    {WHERE          , "WHERE \0"},
    {AS             , "AS \0"},
    {CALL           , "CALL \0"},
    {FROM           , "FROM \0"},
    {TO             , "TO \0"},
    {UPDATE         , "UPDATE \0"},
    {AND            , "AND \0"},
    {OR             , "OR \0"},
    {LIKE           , "LIKE \0"},
    {CREATEDATABASE , "CREATEDATABASE \0"},
    {INTO           , "INTO \0"},
    {IN             , "IN \0"},
    {ORDERBY        , "ORDER BY \0"},
    {VALUES         , "VALUES \0"},
    {SET            , "SET \0"},
    {INNER_JOIN     , "INNER JOIN \0"},
    {ON             , "ON \0"},
    {LEFT_JOIN      , "LEFT JOIN \0"},
    {BETWEEN        , "BETWEEN \0"},
    {RIGHT_JOIN     , "RIGHT JOIN \0"},
    {FULL_JOIN      , "FULL OUTER JOIN \0"},
    {UNION          , "UNION \0"},
    {ALL            , "ALL \0"},
};


typedef struct SQLGenerator//SQL Query Generator. It's a nice helping structure!
{
    static const std::string WILDCARD;
    std::string prepareStatement(std::string table = WILDCARD, std::string columns = WILDCARD, std::string criteria = WILDCARD, std::string pattern = WILDCARD, std::string pattern2 = WILDCARD, size_t statementType = SELECT);
} SQLQuery;

#endif // SQLKEYWORDS_H_INCLUDED
